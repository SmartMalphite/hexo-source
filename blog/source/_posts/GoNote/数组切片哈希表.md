---
title: Go的数组、切片和哈希表
date: 2022-09-06 21:00:49
categories: 
    - Go学习笔记
tags: 
    - GoLang数据结构
---

## 数组与切片介绍
slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。

数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。

而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。

数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。

```go
// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
```

> 注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。

## 常见问题
### 问题1: [3]int 和 [4]int 是同一个类型吗？
不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。
### 问题2: 切片的长度与容量?
Go语言的切片拥有长度和容量。长度是他所包含的元素个数，容量是其底层数组的元素个数。append是切片的长度大于容量后，切片会自动扩容。
#### 问题2.1: 下面的代码输出是什么？
```go
package main

import "fmt"

func main() {
	slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s1 := slice[2:5]
	s2 := s1[2:6:7]

	s2 = append(s2, 100)
	s2 = append(s2, 200)

	s1[2] = 20

	fmt.Println(s1)
	fmt.Println(s2)
	fmt.Println(slice)
}
```
结果:
```go
[2 3 20]
[4 5 6 7 100 200]
[0 1 2 3 20 5 6 7 100 9]
```
s1 从 slice 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。 s2 从 s1 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。
![](https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231135.png)

接着，向 s2 尾部追加一个元素 100.s2 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 s1 都可以看得到。
![](https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231309.png)

再次向 s2 追加元素200. 这时，s2 的容量不够用，该扩容了。于是，s2 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 append 带来的再一次扩容，s2 会在此次扩容的时候多留一些 buffer，将新的容量将扩大为原始容量的2倍，也就是10了。
![](https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231411.png)

最后，修改 s1 索引为2位置的元素.这次只会影响原始数组相应位置的元素。它影响不到 s2 了，人家已经远走高飞了。
![](https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231432.png)

总结:
* 数组/切片在截取时，如不显示指定容量，默认到数组结尾
* 截取得到的数组/切片，只会打印和访问其长度以内的元素，但是实际底层数组可能不止这些元素(不可访问，但是可继续参与截取)

### 问题3: 切片扩容策略?
1.18版本以前: 当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。
1.18版本更新后: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4
> 在进行上述计算后，对长度又进行了一次内存对齐，所以实际容量会大于等于按上述方法计算出的数值。

#### 问题3.1: 下面的代码输出是什么？
```go
package main

import "fmt"

func main() {
    s := []int{5}
    s = append(s, 7)
    s = append(s, 9)
    x := append(s, 11)
    y := append(s, 12)
    fmt.Println(s, x, y)
}
```
|代码	|切片对应状态 |
| ----------- | ----------- |
|s:=[]int{5}| s 只有一个元素，[5] |
|s=append(s, 7)	| s 扩容，容量变为2，[5, 7]
|s=append(s, 9)	| s 扩容，容量变为4，[5, 7, 9]。注意，这时 s 长度是3，容量为4
|x:=append(s, 11)	| 由于 s 的底层数组仍然有空间，因此并不会扩容。这样，底层数组就变成了 [5, 7, 9, 11]。注意，此时 s = [5, 7, 9]，容量为4；x = [5, 7, 9, 11]，容量为4。这里 s 不变
|y:=append(s, 12)	| 这里还是在 s 元素的尾部追加元素，由于 s 的长度为3，容量为4，所以直接在底层数组索引为3的地方填上12。结果：s = [5, 7, 9]，y = [5, 7, 9, 12]，x = [5, 7, 9, 12]，x，y 的长度均为4，容量也均为4

> 这里要注意的是，append函数执行完后，返回的是一个全新的 slice，并且对传入的 slice 并不影响。（但是底层数组是同一个）