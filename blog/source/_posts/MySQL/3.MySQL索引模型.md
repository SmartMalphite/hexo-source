---
title: MySQL索引模型
date: 2022-10-09 21:00:49
categories: 
    - MySQL学习笔记
tags: 
    - 索引模型
---

## MySQL的索引模型

> 索引的出现其实就是为了提高数据查询的效率，就像字典的目录一样。一本 500 页的字典，如果你想快速找到其中的某一个汉子的内容，在不借助目录的情况下，只能慢慢的翻阅很浪费时间，而使用拼音查找目录就会快很多。同样，对于数据库的表而言，索引其实就是它的“目录”。

### 1.索引的常见模型

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里先介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。

#### 1.1 哈希表

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。

需要注意的是，在哈希表中插入新的key点位是直接追加的，而不是有序的，因此新增节点的速度会很快，但是区间查询的速度会很慢，因此这种模型适用于只有等值查询的场景(Memcached 及其他一些 NoSQL 引擎)。

#### 1.2 有序数组

有序数组顾名思义，就是一个排好序列表，这种模型的等值查询和范围查询性能都很好(根据二分法找到对应的值或范围的起点)，但是因为每次插入都要保证数组是有序的，所以更新性能较差。

#### 1.3 搜索树

二叉搜索树同时拥有较高的查询和更新性能，但是如果数据量较大，树的层级会比较深，一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

### 2.Innodb的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。

假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。索引的组织结构的示意图如下

<img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/dcda101051f28502bd5c4402b292e38d.png" alt="img" style="zoom:50%;" />

索引类型可分为主键索引和非主键索引:

* 主键索引的叶子节点存的是整行数据，在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。

* 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？

1. 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；

2. 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

可以看出，使用主键索引可以尽量减少扫描次数，提高查询速度

### 3.索引的维护

>  B+树为了维护索引的有序，插入新值是需要做相应的维护工作，如果依次向后增加数据，逻辑和成本都相对简单。但以上面索引结构的示意图为例，如果要在300和500之间插入数据，则会影响后面的节点，在某些场景下，则还会发生"页分裂"，对性能产生较大影响；同样如果要删除某些数据，也可能会出现"页合并"。

#### 3.1 MySQL数据表存储结构

假设你已经装好了MySQL最新的5.7版本，并且你创建了一个`windmills`库（schema）和`wmills`表。在文件目录（通常是`/var/lib/mysql/`）你会看到以下内容：

```text
data/
  windmills/
      wmills.ibd
      wmills.frm
```

目录下要注意的是这个叫`wmills.ibd`的文件。这个文件由多个段（segments）组成，每个段和一个索引相关。段则由更小一级单位--区 组成，每个区的默认大小为1M，页则是区的下一级构成单位，默认体积为16KB。**页是MySQL的最小存储单元**

按这样算，一个区可以容纳最多64个页，一个页可以容纳2-N个行。行的数量取决于它的大小，由你的表结构定义 (InnoDB要求页至少要有两个行)

<img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210630235552804-20210630235741726.png" style="zoom:50%;" />

#### 3.2 InnoDB中的一颗B+树能存储多少行数据

这里以一颗高度为3的B+树为例(B+树中每行的完整数据都存储在叶子节点，非叶子结点只存储**索引键值**和指向孩子节点的**指针**)

假设主键ID为bigint类型，长度8字节，指针在InnoDB中设置为6字节，这样一个单元总共14字节，一页中可以存储16384/14=1170个指针，换而言之，**每个非叶子节点中最多可以存储约1200个指针**。

假设一行记录的大小约为1K，一页中则可以存储16/1=16行数据。

因此可以得出，一颗高度为3的B+树，在行数据为1K左右时，最多可以存储 1200 * 1200 * 16 约 2000万条数据。

![image-20210701000330687](https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210701000330687.png)

参考链接 : [如何查看根页的Page No以及树高](https://zhuanlan.zhihu.com/p/86137284)

#### 3.3 行数据溢出

Innodb页的默认大小是16kb, 并且要求一页最少有两行数据(如果只有一行数据, B+TREE就失去了意义，退化成了一条双向链表)，因此一行数据的最大长度是8k;

为了尽量保证一页能存储两行数据，innodb自动将字段中超过768字节的部分存储到另外页中并指向溢出页；但需要注意的是，假如有20个大字段，20 * 768 > 8000，此时依旧超过了一行8k的限制，因此会产生报错

#### 3.4 页分裂和页合并

根据B+树的特性，为了维护索引的有序性，如果我们插入数据的是有序的，那么只需依次写满数据页，并在写满后切换到下一页继续写入；而当我们不按顺序随机插入数据时，如果插在多条记录之间，则会导致此页内后面的``数据依次向后移动``，甚至如果页已经满了，则会发生``页分裂``(例如当前页记录主键id为10、12、14的3条数据且已写满，这时插入一个11，则会在此页之后再增加一个页并改变相邻页之间的指针指向，并将部分数据移动到新页 )，而顺序写入写满页后就不会有移动数据以及页分裂的问题；

与之对应的还有页合并操作，当我们删除一定数量的数据使相邻页的数据分别低于一定比例之后为了节省空间则会发生``页合并``，移动数据并改变相邻页之间的指针指向，类似于活页本把本页内容摘抄到上一页并将此页拿掉，也是比较消耗性能的；

> 因此建议使用自增主键id避免页分裂，使用逻辑删除代替物理删除避免页合并

